<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Chess | Christopher Nolan Edition</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --dark-bg: #0f172a;
            --darker-bg: #0a0f1f;
            --light-bg: #1e293b;
            --accent: #3b82f6;
            --accent-light: #60a5fa;
            --text: #f8fafc;
            --text-secondary: #cbd5e1;
            --board-dark: #769656;
            --board-light: #eeeed2;
            --highlight: #fbbf24;
            --danger: #ef4444;
            --success: #10b981;
        }

        body {
            background: linear-gradient(135deg, var(--dark-bg), var(--darker-bg));
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, var(--accent), var(--accent-light));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 10px rgba(59, 130, 246, 0.2);
        }

        .tagline {
            font-size: 1.1rem;
            color: var(--text-secondary);
            font-style: italic;
        }

        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
        }

        .game-section {
            flex: 1;
            min-width: 500px;
            max-width: 700px;
        }

        .sidebar {
            flex: 0 0 320px;
            background: rgba(30, 41, 59, 0.7);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(59, 130, 246, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .board-container {
            position: relative;
            background: rgba(30, 41, 59, 0.7);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(59, 130, 246, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            aspect-ratio: 1 / 1;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            border: 3px solid var(--light-bg);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            position: relative;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
        }

        .square.light {
            background-color: var(--board-light);
        }

        .square.dark {
            background-color: var(--board-dark);
        }

        .square.highlight {
            box-shadow: inset 0 0 0 3px var(--highlight);
            z-index: 2;
        }

        .square.last-move {
            box-shadow: inset 0 0 0 3px var(--accent);
            z-index: 2;
        }

        .square.valid-move::after {
            content: '';
            width: 25%;
            height: 25%;
            border-radius: 50%;
            background-color: rgba(59, 130, 246, 0.7);
            position: absolute;
        }

        .piece {
            font-size: 2.8rem;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            z-index: 5;
            transition: transform 0.2s ease;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }

        .piece.dragging {
            cursor: grabbing;
            transform: scale(1.1);
            z-index: 10;
        }

        .piece.black {
            color: #1e293b;
        }

        .piece.white {
            color: #f8fafc;
        }

        .coordinate {
            position: absolute;
            font-size: 0.8rem;
            font-weight: bold;
            color: rgba(0, 0, 0, 0.7);
            z-index: 1;
        }

        .coordinate.row {
            left: 5px;
            top: 5px;
        }

        .coordinate.col {
            right: 5px;
            bottom: 5px;
        }

        .dark .coordinate {
            color: rgba(255, 255, 255, 0.7);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        button:hover {
            background: var(--accent-light);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(59, 130, 246, 0.4);
        }

        button.secondary {
            background: var(--light-bg);
        }

        button.secondary:hover {
            background: #334155;
        }

        button.danger {
            background: var(--danger);
        }

        button.danger:hover {
            background: #f87171;
        }

        .game-info {
            margin-bottom: 25px;
        }

        .info-box {
            background: rgba(15, 23, 42, 0.6);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .info-box h3 {
            margin-bottom: 15px;
            color: var(--accent-light);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status {
            font-size: 1.2rem;
            font-weight: 600;
            padding: 12px;
            border-radius: 8px;
            background: rgba(15, 23, 42, 0.6);
            text-align: center;
            margin-bottom: 20px;
        }

        .moves-list {
            max-height: 200px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .move-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 5px;
            background: rgba(15, 23, 42, 0.3);
        }

        .move-item:nth-child(odd) {
            background: rgba(15, 23, 42, 0.5);
        }

        .move-item.current {
            background: rgba(59, 130, 246, 0.3);
            border-left: 3px solid var(--accent);
        }

        .tip-card {
            background: rgba(15, 23, 42, 0.6);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid var(--highlight);
        }

        .tip-card h4 {
            color: var(--highlight);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-box {
            background: rgba(15, 23, 42, 0.6);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            min-height: 40px;
        }

        .captured-piece {
            font-size: 1.5rem;
            opacity: 0.7;
        }

        footer {
            text-align: center;
            padding: 25px 0;
            margin-top: 20px;
            border-top: 1px solid rgba(59, 130, 246, 0.2);
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        @media (max-width: 1100px) {
            .main-content {
                flex-direction: column;
                align-items: center;
            }
            
            .game-section, .sidebar {
                width: 100%;
                max-width: 700px;
                min-width: unset;
            }
        }

        @media (max-width: 600px) {
            .board-container {
                padding: 15px;
            }
            
            .piece {
                font-size: 2rem;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 100%;
                justify-content: center;
            }
        }

        /* Animation for piece movement */
        @keyframes movePiece {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .piece.moved {
            animation: movePiece 0.3s ease;
        }

        /* Floating pieces effect */
        .floating-piece {
            position: absolute;
            font-size: 1.5rem;
            opacity: 0.1;
            pointer-events: none;
            z-index: 0;
        }

        /* Modal for game end */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--dark-bg);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            border: 2px solid var(--accent);
            box-shadow: 0 0 40px rgba(59, 130, 246, 0.3);
        }

        .modal h2 {
            color: var(--accent);
            margin-bottom: 20px;
            font-size: 2.2rem;
        }

        .modal p {
            margin-bottom: 30px;
            font-size: 1.2rem;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-chess-queen"></i> Quantum Chess</h1>
            <p class="tagline">A Christopher Nolan-inspired chess experience with smooth gameplay and strategic insights</p>
        </header>
        
        <div class="main-content">
            <div class="game-section">
                <div class="board-container">
                    <div class="board" id="chessboard">
                        <!-- Chessboard will be generated by JavaScript -->
                    </div>
                    
                    <div class="controls">
                        <button id="newGameBtn">
                            <i class="fas fa-plus-circle"></i> New Game
                        </button>
                        <button id="undoBtn" class="secondary">
                            <i class="fas fa-undo"></i> Undo Move
                        </button>
                        <button id="hintBtn" class="secondary">
                            <i class="fas fa-lightbulb"></i> Show Hint
                        </button>
                        <button id="flipBoardBtn">
                            <i class="fas fa-sync-alt"></i> Flip Board
                        </button>
                    </div>
                </div>
                
                <div class="status" id="gameStatus">
                    White's turn. Game in progress.
                </div>
            </div>
            
            <div class="sidebar">
                <div class="game-info">
                    <div class="info-box">
                        <h3><i class="fas fa-chess-board"></i> Game Info</h3>
                        <div class="stats">
                            <div class="stat-box">
                                <div class="stat-value" id="whiteTime">15:00</div>
                                <div class="stat-label">White (You)</div>
                                <div class="captured-pieces" id="whiteCaptured"></div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value" id="blackTime">15:00</div>
                                <div class="stat-label">Black (AI)</div>
                                <div class="captured-pieces" id="blackCaptured"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="info-box">
                        <h3><i class="fas fa-history"></i> Move History</h3>
                        <div class="moves-list" id="moveHistory">
                            <!-- Move history will be populated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="tip-card">
                        <h4><i class="fas fa-brain"></i> Pro Tip</h4>
                        <p id="tipText">Control the center of the board to gain more space and better piece mobility.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Quantum Chess | Christopher Nolan Edition | Designed for smooth gameplay and strategic depth</p>
            <p>Deploy this on Vercel for instant access anywhere</p>
        </footer>
    </div>
    
    <!-- Game End Modal -->
    <div class="modal" id="gameEndModal">
        <div class="modal-content">
            <h2 id="gameResult">Checkmate!</h2>
            <p id="gameResultDescription">White wins by checkmate in 24 moves.</p>
            <div class="controls">
                <button id="playAgainBtn">
                    <i class="fas fa-redo"></i> Play Again
                </button>
                <button id="analysisBtn" class="secondary">
                    <i class="fas fa-chart-line"></i> View Analysis
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // Chess game implementation
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize variables
            let board = [];
            let currentPlayer = 'white';
            let selectedPiece = null;
            let validMoves = [];
            let moveHistory = [];
            let capturedPieces = { white: [], black: [] };
            let gameOver = false;
            let boardFlipped = false;
            let lastMove = null;
            let moveCount = 0;
            let whiteTime = 900; // 15 minutes in seconds
            let blackTime = 900;
            let timerInterval = null;
            
            // Chess piece Unicode characters
            const pieces = {
                king: { white: '♔', black: '♚' },
                queen: { white: '♕', black: '♛' },
                rook: { white: '♖', black: '♜' },
                bishop: { white: '♗', black: '♝' },
                knight: { white: '♘', black: '♞' },
                pawn: { white: '♙', black: '♟' }
            };
            
            // Tips for players
            const tips = [
                "Control the center of the board to gain more space and better piece mobility.",
                "Develop your knights and bishops early in the game.",
                "Castle early to protect your king and connect your rooks.",
                "Don't move the same piece twice in the opening unless necessary.",
                "Keep your pieces protected and avoid leaving them en prise (able to be captured for free).",
                "Try to think at least 2-3 moves ahead when planning your strategy.",
                "Pay attention to your opponent's threats before making your own moves.",
                "In the endgame, activate your king as a powerful piece.",
                "Passed pawns (pawns with no opposing pawns to stop them) are extremely valuable in the endgame.",
                "When ahead in material, consider trading pieces to simplify the position.",
                "When behind in material, avoid trading and try to create counterplay.",
                "Always check for checks, captures, and threats when it's your opponent's turn."
            ];
            
            // Initialize the chessboard
            function initBoard() {
                board = [];
                
                // Create empty 8x8 board
                for (let row = 0; row < 8; row++) {
                    board[row] = [];
                    for (let col = 0; col < 8; col++) {
                        board[row][col] = null;
                    }
                }
                
                // Set up pawns
                for (let col = 0; col < 8; col++) {
                    board[1][col] = { type: 'pawn', color: 'black', hasMoved: false };
                    board[6][col] = { type: 'pawn', color: 'white', hasMoved: false };
                }
                
                // Set up other pieces
                const pieceOrder = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                
                for (let col = 0; col < 8; col++) {
                    board[0][col] = { type: pieceOrder[col], color: 'black', hasMoved: false };
                    board[7][col] = { type: pieceOrder[col], color: 'white', hasMoved: false };
                }
                
                renderBoard();
                updateGameStatus();
                startTimer();
                showRandomTip();
            }
            
            // Render the chessboard
            function renderBoard() {
                const boardElement = document.getElementById('chessboard');
                boardElement.innerHTML = '';
                
                // Add floating pieces for visual effect
                for (let i = 0; i < 15; i++) {
                    const floatingPiece = document.createElement('div');
                    floatingPiece.className = 'floating-piece';
                    floatingPiece.textContent = Object.values(pieces).map(p => p.white).join('').charAt(i % 12);
                    floatingPiece.style.left = `${Math.random() * 100}%`;
                    floatingPiece.style.top = `${Math.random() * 100}%`;
                    floatingPiece.style.transform = `rotate(${Math.random() * 360}deg)`;
                    boardElement.appendChild(floatingPiece);
                }
                
                // Create board squares
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        const displayRow = boardFlipped ? 7 - row : row;
                        const displayCol = boardFlipped ? 7 - col : col;
                        
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = displayRow;
                        square.dataset.col = displayCol;
                        
                        // Highlight last move
                        if (lastMove && 
                            ((lastMove.from.row === displayRow && lastMove.from.col === displayCol) ||
                             (lastMove.to.row === displayRow && lastMove.to.col === displayCol))) {
                            square.classList.add('last-move');
                        }
                        
                        // Highlight selected piece
                        if (selectedPiece && selectedPiece.row === displayRow && selectedPiece.col === displayCol) {
                            square.classList.add('highlight');
                        }
                        
                        // Highlight valid moves
                        if (validMoves.some(move => move.row === displayRow && move.col === displayCol)) {
                            square.classList.add('valid-move');
                        }
                        
                        // Add coordinates
                        if (displayRow === 7) {
                            const colCoordinate = document.createElement('div');
                            colCoordinate.className = 'coordinate col';
                            colCoordinate.textContent = String.fromCharCode(97 + displayCol);
                            square.appendChild(colCoordinate);
                        }
                        
                        if (displayCol === 0) {
                            const rowCoordinate = document.createElement('div');
                            rowCoordinate.className = 'coordinate row';
                            rowCoordinate.textContent = 8 - displayRow;
                            square.appendChild(rowCoordinate);
                        }
                        
                        // Add piece if present
                        const piece = board[displayRow][displayCol];
                        if (piece) {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = `piece ${piece.color}`;
                            pieceElement.textContent = pieces[piece.type][piece.color];
                            pieceElement.dataset.row = displayRow;
                            pieceElement.dataset.col = displayCol;
                            
                            // Add drag events
                            pieceElement.draggable = true;
                            pieceElement.addEventListener('dragstart', handleDragStart);
                            pieceElement.addEventListener('dragend', handleDragEnd);
                            
                            // Add click event
                            pieceElement.addEventListener('click', () => handlePieceClick(displayRow, displayCol));
                            
                            square.appendChild(pieceElement);
                        } else {
                            // Add click event for empty squares
                            square.addEventListener('click', () => handleSquareClick(displayRow, displayCol));
                        }
                        
                        // Add drop event for squares
                        square.addEventListener('dragover', handleDragOver);
                        square.addEventListener('drop', handleDrop);
                        
                        boardElement.appendChild(square);
                    }
                }
                
                updateCapturedPiecesDisplay();
            }
            
            // Handle piece click
            function handlePieceClick(row, col) {
                if (gameOver || board[row][col].color !== currentPlayer) return;
                
                if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                    // Deselect if clicking the same piece
                    selectedPiece = null;
                    validMoves = [];
                } else {
                    // Select the piece
                    selectedPiece = { row, col };
                    validMoves = getValidMoves(row, col);
                }
                
                renderBoard();
            }
            
            // Handle square click
            function handleSquareClick(row, col) {
                if (!selectedPiece || gameOver) return;
                
                // Check if the clicked square is a valid move
                const isValidMove = validMoves.some(move => move.row === row && move.col === col);
                
                if (isValidMove) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col);
                    selectedPiece = null;
                    validMoves = [];
                } else {
                    // Deselect if clicking an invalid square
                    selectedPiece = null;
                    validMoves = [];
                    renderBoard();
                }
            }
            
            // Get valid moves for a piece
            function getValidMoves(row, col) {
                const piece = board[row][col];
                if (!piece) return [];
                
                const moves = [];
                
                // Helper function to check if square is empty or contains opponent's piece
                const canMoveTo = (r, c) => {
                    if (r < 0 || r > 7 || c < 0 || c > 7) return false;
                    if (!board[r][c]) return true;
                    return board[r][c].color !== piece.color;
                };
                
                // Helper function for sliding pieces (rooks, bishops, queens)
                const addSlidingMoves = (directions) => {
                    for (const [dr, dc] of directions) {
                        let r = row + dr;
                        let c = col + dc;
                        
                        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                            if (!board[r][c]) {
                                moves.push({ row: r, col: c });
                            } else if (board[r][c].color !== piece.color) {
                                moves.push({ row: r, col: c });
                                break;
                            } else {
                                break;
                            }
                            
                            r += dr;
                            c += dc;
                        }
                    }
                };
                
                switch (piece.type) {
                    case 'pawn':
                        const direction = piece.color === 'white' ? -1 : 1;
                        const startRow = piece.color === 'white' ? 6 : 1;
                        
                        // Move forward one square
                        if (row + direction >= 0 && row + direction < 8 && !board[row + direction][col]) {
                            moves.push({ row: row + direction, col });
                            
                            // Move forward two squares from starting position
                            if (row === startRow && !board[row + 2 * direction][col]) {
                                moves.push({ row: row + 2 * direction, col });
                            }
                        }
                        
                        // Capture diagonally
                        if (row + direction >= 0 && row + direction < 8) {
                            if (col - 1 >= 0 && board[row + direction][col - 1] && board[row + direction][col - 1].color !== piece.color) {
                                moves.push({ row: row + direction, col: col - 1 });
                            }
                            if (col + 1 < 8 && board[row + direction][col + 1] && board[row + direction][col + 1].color !== piece.color) {
                                moves.push({ row: row + direction, col: col + 1 });
                            }
                        }
                        break;
                        
                    case 'knight':
                        const knightMoves = [
                            [2, 1], [2, -1], [-2, 1], [-2, -1],
                            [1, 2], [1, -2], [-1, 2], [-1, -2]
                        ];
                        
                        for (const [dr, dc] of knightMoves) {
                            const r = row + dr;
                            const c = col + dc;
                            if (canMoveTo(r, c)) {
                                moves.push({ row: r, col: c });
                            }
                        }
                        break;
                        
                    case 'bishop':
                        addSlidingMoves([[1, 1], [1, -1], [-1, 1], [-1, -1]]);
                        break;
                        
                    case 'rook':
                        addSlidingMoves([[1, 0], [-1, 0], [0, 1], [0, -1]]);
                        break;
                        
                    case 'queen':
                        addSlidingMoves([[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]]);
                        break;
                        
                    case 'king':
                        const kingMoves = [
                            [1, 0], [-1, 0], [0, 1], [0, -1],
                            [1, 1], [1, -1], [-1, 1], [-1, -1]
                        ];
                        
                        for (const [dr, dc] of kingMoves) {
                            const r = row + dr;
                            const c = col + dc;
                            if (canMoveTo(r, c)) {
                                moves.push({ row: r, col: c });
                            }
                        }
                        
                        // Castling (simplified - not checking for check conditions)
                        if (!piece.hasMoved) {
                            // Kingside castling
                            if (!board[row][5] && !board[row][6] && board[row][7] && 
                                board[row][7].type === 'rook' && !board[row][7].hasMoved) {
                                moves.push({ row, col: 6, isCastle: true });
                            }
                            
                            // Queenside castling
                            if (!board[row][1] && !board[row][2] && !board[row][3] && board[row][0] && 
                                board[row][0].type === 'rook' && !board[row][0].hasMoved) {
                                moves.push({ row, col: 2, isCastle: true });
                            }
                        }
                        break;
                }
                
                return moves;
            }
            
            // Move a piece
            function movePiece(fromRow, fromCol, toRow, toCol, isAIMove = false) {
                const piece = board[fromRow][fromCol];
                const targetPiece = board[toRow][toCol];
                
                // Handle castling
                if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {
                    // Move the rook
                    if (toCol === 6) { // Kingside
                        board[toRow][5] = board[toRow][7];
                        board[toRow][7] = null;
                        board[toRow][5].hasMoved = true;
                    } else if (toCol === 2) { // Queenside
                        board[toRow][3] = board[toRow][0];
                        board[toRow][0] = null;
                        board[toRow][3].hasMoved = true;
                    }
                }
                
                // Handle pawn promotion (simplified - always promote to queen)
                if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                    piece.type = 'queen';
                }
                
                // Capture piece if needed
                if (targetPiece) {
                    capturedPieces[piece.color === 'white' ? 'black' : 'white'].push(targetPiece.type);
                }
                
                // Move the piece
                board[toRow][toCol] = piece;
                board[fromRow][fromCol] = null;
                piece.hasMoved = true;
                
                // Record the move
                const moveNotation = getMoveNotation(fromRow, fromCol, toRow, toCol, targetPiece);
                moveCount++;
                const moveItem = {
                    number: Math.ceil(moveCount / 2),
                    white: currentPlayer === 'white' ? moveNotation : null,
                    black: currentPlayer === 'black' ? moveNotation : null,
                    from: { row: fromRow, col: fromCol },
                    to: { row: toRow, col: toCol }
                };
                
                // Check if we need to add to an existing move
                if (moveHistory.length > 0 && moveHistory[moveHistory.length - 1].white && !moveHistory[moveHistory.length - 1].black) {
                    moveHistory[moveHistory.length - 1].black = currentPlayer === 'black' ? moveNotation : null;
                } else {
                    moveHistory.push(moveItem);
                }
                
                // Update last move
                lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
                
                // Switch player
                currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                
                // Update UI
                renderBoard();
                updateMoveHistoryDisplay();
                updateGameStatus();
                
                // Check for game end
                checkGameEnd();
                
                // If it's black's turn (AI), make a move after a delay
                if (!gameOver && currentPlayer === 'black' && !isAIMove) {
                    setTimeout(makeAIMove, 800);
                }
                
                // Show a random tip occasionally
                if (Math.random() > 0.7) {
                    showRandomTip();
                }
            }
            
            // Get algebraic notation for a move
            function getMoveNotation(fromRow, fromCol, toRow, toCol, capturedPiece) {
                const piece = board[toRow][toCol];
                const file = String.fromCharCode(97 + fromCol);
                const rank = 8 - fromRow;
                const toFile = String.fromCharCode(97 + toCol);
                const toRank = 8 - toRow;
                
                let notation = '';
                
                // For pawns, just show the destination square
                if (piece.type === 'pawn') {
                    if (capturedPiece) {
                        notation = `${file}x${toFile}${toRank}`;
                    } else {
                        notation = `${toFile}${toRank}`;
                    }
                } else {
                    // For other pieces, use the piece abbreviation
                    const pieceAbbr = piece.type === 'knight' ? 'N' : piece.type.charAt(0).toUpperCase();
                    notation = `${pieceAbbr}${toFile}${toRank}`;
                    
                    if (capturedPiece) {
                        notation = `${pieceAbbr}x${toFile}${toRank}`;
                    }
                }
                
                return notation;
            }
            
            // Make an AI move
            function makeAIMove() {
                if (gameOver || currentPlayer !== 'black') return;
                
                // Simple AI: get all valid moves and pick one randomly
                const allMoves = [];
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color === 'black') {
                            const moves = getValidMoves(row, col);
                            moves.forEach(move => {
                                allMoves.push({
                                    from: { row, col },
                                    to: { row: move.row, col: move.col }
                                });
                            });
                        }
                    }
                }
                
                if (allMoves.length > 0) {
                    const randomMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                    movePiece(randomMove.from.row, randomMove.from.col, randomMove.to.row, randomMove.to.col, true);
                }
            }
            
            // Check if the game has ended
            function checkGameEnd() {
                // Check for checkmate or stalemate (simplified)
                let hasValidMoves = false;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color === currentPlayer) {
                            const moves = getValidMoves(row, col);
                            if (moves.length > 0) {
                                hasValidMoves = true;
                                break;
                            }
                        }
                    }
                    if (hasValidMoves) break;
                }
                
                if (!hasValidMoves) {
                    gameOver = true;
                    clearInterval(timerInterval);
                    
                    // Check if king is in check (simplified check detection)
                    let kingInCheck = false;
                    kingSearch:
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const piece = board[row][col];
                            if (piece && piece.type === 'king' && piece.color === currentPlayer) {
                                // Very simplified check detection
                                kingInCheck = true;
                                break kingSearch;
                            }
                        }
                    }
                    
                    const winner = currentPlayer === 'white' ? 'Black' : 'White';
                    showGameEndModal(kingInCheck ? `${winner} wins by checkmate!` : "Stalemate! The game is a draw.");
                }
            }
            
            // Update game status display
            function updateGameStatus() {
                const statusElement = document.getElementById('gameStatus');
                
                if (gameOver) {
                    statusElement.textContent = "Game over!";
                    statusElement.style.color = var('--accent');
                } else {
                    statusElement.textContent = `${currentPlayer === 'white' ? 'White' : 'Black'}'s turn. ${moveCount} moves played.`;
                    statusElement.style.color = currentPlayer === 'white' ? '#f8fafc' : '#1e293b';
                    statusElement.style.backgroundColor = currentPlayer === 'white' ? 'rgba(30, 41, 59, 0.8)' : 'rgba(15, 23, 42, 0.8)';
                }
            }
            
            // Update move history display
            function updateMoveHistoryDisplay() {
                const moveHistoryElement = document.getElementById('moveHistory');
                moveHistoryElement.innerHTML = '';
                
                moveHistory.forEach((move, index) => {
                    const moveItem = document.createElement('div');
                    moveItem.className = 'move-item';
                    
                    if (index === moveHistory.length - 1) {
                        moveItem.classList.add('current');
                    }
                    
                    moveItem.innerHTML = `
                        <span>${move.number}.</span>
                        <span>${move.white || '...'}</span>
                        <span>${move.black || ''}</span>
                    `;
                    
                    moveHistoryElement.appendChild(moveItem);
                });
                
                // Scroll to bottom
                moveHistoryElement.scrollTop = moveHistoryElement.scrollHeight;
            }
            
            // Update captured pieces display
            function updateCapturedPiecesDisplay() {
                const whiteCapturedElement = document.getElementById('whiteCaptured');
                const blackCapturedElement = document.getElementById('blackCaptured');
                
                whiteCapturedElement.innerHTML = capturedPieces.white.map(piece => 
                    `<div class="captured-piece">${pieces[piece].white}</div>`
                ).join('');
                
                blackCapturedElement.innerHTML = capturedPieces.black.map(piece => 
                    `<div class="captured-piece">${pieces[piece].black}</div>`
                ).join('');
            }
            
            // Show a random tip
            function showRandomTip() {
                const tipTextElement = document.getElementById('tipText');
                const randomTip = tips[Math.floor(Math.random() * tips.length)];
                tipTextElement.textContent = randomTip;
            }
            
            // Start the timer
            function startTimer() {
                clearInterval(timerInterval);
                
                timerInterval = setInterval(() => {
                    if (currentPlayer === 'white') {
                        whiteTime--;
                    } else {
                        blackTime--;
                    }
                    
                    updateTimerDisplay();
                    
                    // Check for time out
                    if (whiteTime <= 0 || blackTime <= 0) {
                        clearInterval(timerInterval);
                        const winner = whiteTime <= 0 ? 'Black' : 'White';
                        showGameEndModal(`${winner} wins on time!`);
                    }
                }, 1000);
            }
            
            // Update timer display
            function updateTimerDisplay() {
                const whiteTimeElement = document.getElementById('whiteTime');
                const blackTimeElement = document.getElementById('blackTime');
                
                whiteTimeElement.textContent = formatTime(whiteTime);
                blackTimeElement.textContent = formatTime(blackTime);
                
                // Highlight current player's timer
                if (currentPlayer === 'white') {
                    whiteTimeElement.style.color = var('--accent-light');
                    blackTimeElement.style.color = var('--text');
                } else {
                    whiteTimeElement.style.color = var('--text');
                    blackTimeElement.style.color = var('--accent-light');
                }
            }
            
            // Format time as MM:SS
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Show game end modal
            function showGameEndModal(message) {
                const modal = document.getElementById('gameEndModal');
                const gameResult = document.getElementById('gameResult');
                const gameResultDescription = document.getElementById('gameResultDescription');
                
                gameResult.textContent = gameOver ? "Game Over" : "Checkmate!";
                gameResultDescription.textContent = message;
                
                modal.style.display = 'flex';
                gameOver = true;
            }
            
            // Drag and drop functionality
            let draggedPiece = null;
            
            function handleDragStart(e) {
                if (gameOver) {
                    e.preventDefault();
                    return;
                }
                
                const pieceElement = e.target;
                const row = parseInt(pieceElement.dataset.row);
                const col = parseInt(pieceElement.dataset.col);
                const piece = board[row][col];
                
                if (piece.color !== currentPlayer) {
                    e.preventDefault();
                    return;
                }
                
                draggedPiece = { row, col };
                pieceElement.classList.add('dragging');
                e.dataTransfer.setData('text/plain', ''); // Required for Firefox
                
                // Show valid moves
                selectedPiece = { row, col };
                validMoves = getValidMoves(row, col);
                renderBoard();
            }
            
            function handleDragEnd(e) {
                e.target.classList.remove('dragging');
                selectedPiece = null;
                validMoves = [];
                renderBoard();
            }
            
            function handleDragOver(e) {
                e.preventDefault();
            }
            
            function handleDrop(e) {
                e.preventDefault();
                
                if (!draggedPiece || gameOver) return;
                
                const square = e.target.closest('.square');
                if (!square) return;
                
                const toRow = parseInt(square.dataset.row);
                const toCol = parseInt(square.dataset.col);
                
                // Check if the move is valid
                const isValidMove = validMoves.some(move => move.row === toRow && move.col === toCol);
                
                if (isValidMove) {
                    movePiece(draggedPiece.row, draggedPiece.col, toRow, toCol);
                }
                
                draggedPiece = null;
            }
            
            // Event listeners for buttons
            document.getElementById('newGameBtn').addEventListener('click', () => {
                initBoard();
                moveHistory = [];
                capturedPieces = { white: [], black: [] };
                moveCount = 0;
                currentPlayer = 'white';
                gameOver = false;
                lastMove = null;
                whiteTime = 900;
                blackTime = 900;
                updateTimerDisplay();
                updateMoveHistoryDisplay();
                updateGameStatus();
                
                // Hide modal if open
                document.getElementById('gameEndModal').style.display = 'none';
            });
            
            document.getElementById('undoBtn').addEventListener('click', () => {
                // For simplicity, just reset the game
                if (moveHistory.length > 0) {
                    alert("Undo feature is simplified in this demo. For a full implementation, consider using a chess library.");
                }
            });
            
            document.getElementById('hintBtn').addEventListener('click', () => {
                if (gameOver || currentPlayer !== 'white') {
                    alert("Hint is only available during your turn (white).");
                    return;
                }
                
                // Show a random valid move as a hint
                const allMoves = [];
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color === 'white') {
                            const moves = getValidMoves(row, col);
                            moves.forEach(move => {
                                allMoves.push({
                                    from: { row, col },
                                    to: { row: move.row, col: move.col }
                                });
                            });
                        }
                    }
                }
                
                if (allMoves.length > 0) {
                    const randomMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                    
                    // Highlight the suggested move
                    selectedPiece = randomMove.from;
                    validMoves = [randomMove.to];
                    renderBoard();
                    
                    // Remove highlight after 2 seconds
                    setTimeout(() => {
                        selectedPiece = null;
                        validMoves = [];
                        renderBoard();
                    }, 2000);
                    
                    alert(`Hint: Consider moving your piece from ${String.fromCharCode(97 + randomMove.from.col)}${8 - randomMove.from.row} to ${String.fromCharCode(97 + randomMove.to.col)}${8 - randomMove.to.row}`);
                }
            });
            
            document.getElementById('flipBoardBtn').addEventListener('click', () => {
                boardFlipped = !boardFlipped;
                renderBoard();
            });
            
            document.getElementById('playAgainBtn').addEventListener('click', () => {
                document.getElementById('gameEndModal').style.display = 'none';
                initBoard();
                moveHistory = [];
                capturedPieces = { white: [], black: [] };
                moveCount = 0;
                currentPlayer = 'white';
                gameOver = false;
                lastMove = null;
                whiteTime = 900;
                blackTime = 900;
                updateTimerDisplay();
                updateMoveHistoryDisplay();
                updateGameStatus();
            });
            
            document.getElementById('analysisBtn').addEventListener('click', () => {
                alert("Game analysis feature would show detailed stats and move evaluation. In a full implementation, this would integrate with a chess engine.");
            });
            
            // Initialize the game
            initBoard();
            
            // Display initial tip
            showRandomTip();
        });
    </script>
</body>
</html> 